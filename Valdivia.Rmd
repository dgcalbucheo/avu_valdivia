---
title: "Estudio AVU-indicadores Socioeconómicos (SEC) manzanas censales Valdivia"
output: 
  html_notebook:
    df_print: paged
---

## Objetivo: 
Evaluar la correlación entre índices SEC y el porcentaje de AVU de las manzanas censales de Valdivia

## Pasos:
1) Obtener datos de manzanas censales (Censo 2017) de Valdivia (.shp)
2) Revisar indicadores SEC de manzanas censales
3) Definir BUFFER a las manzanas censales
4) Calcular el NDVI promedio y el % de AVU con "rgee" (Landsat8)
5) Evaluar correlaciones


Cargamos los paquetes. "censo2017" se descarga de github/ropensci
```{r}
pkgs = c("ggplot2","sf","dplyr","cartography","leaflet","rgdal","raster","tmap", "tibble", "terra")
lapply(pkgs, require, character.only = TRUE)
```

## 1. Obtener datos de manzanas censales (Censo 2017) de Valdivia
```{r}
setwd("C:\\Users\\dgcal\\Documents\\Github\\avu_valdivia")
mapvald = st_read("mapvald.shp")
```


## 2. Revisar indicadores SEC de manzanas censales

## 2.1. Población migrante
```{r}
mapvald<-mapvald%>%
  mutate(PERSONAS_E = na_if(PERSONAS_E, "Indeterminado"))

mapvald$porcentaje_migr <-
  (as.numeric(mapvald$PERSONAS_E)/mapvald$TOTAL_P) * 100
```

## 2.2. Pueblos originarios
```{r}
mapvald<-mapvald%>%
  mutate(PUEBLOS = na_if(PUEBLOS, "Indeterminado"))

mapvald$porcentaje_ind <-
  (as.numeric(mapvald$PUEBLOS)/mapvald$TOTAL_P) * 100
```

## 2.3. Materialidad viviendas
```{r}
#Pendiente
```


## 3. Definir Buffer (100m) para cada manzana censal
```{r}
mapvald100<-mapvald%>%
  sf::st_buffer(100)
#st_write(mapvald100, "mapvald100.shp", driver = "ESRI Shapefile")
```


Plot
```{r}
leafsync::latticeview(mapview::mapview(mapvald),
                      mapview::mapview(mapvald100))

#Se ve bien el buffer
#Seguimos
```

## 4. Calcular el NDVI
Cargamos el raster descargado desde GEE
```{r}
imagen<-list.files(pattern='*.tif', full.names=TRUE)
bandassep<-brick(stack(imagen)) #esto es por si quiero que el raster tenga hartas capas, por ejemplo, por fecha

plot(bandassep)
```

Calculamos el NDVI
```{r}
ndvi<-(bandassep$B5-bandassep$B4)/(bandassep$B5+bandassep$B4)
plot(ndvi,
     main="NDVI Valdivia y Niebla - Septiembre 2020")
```


Veamos el histograma del NDVI/pixel
```{r}
hist(ndvi,
     main = "NDVI: Distribución de los pixeles VALDIVIA/NIEBLA Sept 2020",
     col = "springgreen",
     xlab = "valores del NDVI")
```


Intentaremos clippear el raster con el ndvi en el mapa de valdivia
```{r}
r = crop(ndvi, mapvald)
#they do not overlap, so...
crs(mapvald100)

```

```{r}
crs(ndvi)
```

## 4.1 Reproyectamos a UTM (18S), veamos con este método
```{r}
test<- st_transform(mapvald, crs=32718) #32718
test2<- projectRaster(ndvi, crs=32718)

r = crop(test2,extent(test))
r2 = mask(r, test)
plot(r2)

#funcionó!!!
```


Ahora si, corregimos el mapa que tiene el buffer (100m) y el raster (ndvi)
```{r}
mapvald100<- st_transform(mapvald100, crs=32718) #32718
ndvi<- projectRaster(ndvi, crs=32718)

```



Método anterior*, no sirve mucho porque corta la imagen al polígono, pero lo dejo igual por si acaso
```{r}
#r = crop(ndvi,extent(mapvald100))
#r2 = mask(r, mapvald100)
#plot(r2)
```


## 4.2 Extraemos zonal stats del ndvi para clipearlo a mapvald (después hay que revisar cómo clipearlo con un buffer)
```{r}
mapvald<-
  mapvald%>%mutate(
    ndvimean = extract(ndvi, mapvald, fun = mean, na.rm = TRUE))
```

## 4.3 Figura exploratoria
```{r}
ggplot(mapvald, aes(x = porcentaje_ind, y = ndvimean))+
         geom_point()+
  geom_smooth(method="lm")+
         theme_classic()
```


## 4.4 Ahora calculamos qué superficie es Área Verde Urbana con distintos valores de NDVI

Primero con NDVI >= 0.3
```{r}
fun03 <- (function(x){x[x<0.3]<- 0; x[x>=0.3]<- 1 ; return(x)})
avu03 <- calc(ndvi, fun03)
plot(avu03,
     main="AVU Valdivia y Niebla - Septiembre 2020")
```

Ahora con NDVI >=0.35
```{r}
fun035 <- (function(x){x[x<0.35]<- 0; x[x>=0.35]<- 1 ; return(x)})
avu035 <- calc(ndvi, fun035)
plot(avu035,
     main="AVU Valdivia y Niebla - Septiembre 2020 (NDVI >= 0.35)")
```

Ahora extraemos los mismos zonal stats que sacamos del NDVI, pero de las AVU (0.3 y 0.35). Aún está pendiente hacerlo al BUFFER
```{r}
mapvald<-
  mapvald%>%mutate(
    avu03 = extract(avu03, mapvald, fun = mean, na.rm = TRUE))

mapvald<-
  mapvald%>%mutate(
    avu035 = extract(avu035, mapvald, fun = mean, na.rm = TRUE))

#PENDIENTE, NECESITO EXTRAER EL VALOR SUM/TOTAL DE CADA POLÍGONO
```

Veámos qué tal
Figura exploratoria
```{r}
ggplot(mapvald, aes(x = porcentaje_ind, y = avu035))+
         geom_point()+
  geom_smooth(method="lm")+
         theme_classic()
```

